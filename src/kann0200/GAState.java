package kann0200;

import java.util.ArrayList;
import java.util.Set;
import java.util.UUID;

import kann0200.Combat;
import kann0200.Pathing;
import kann0200.Vectoring;
import spacesettlers.actions.AbstractAction;
import spacesettlers.actions.DoNothingAction;
import spacesettlers.graphics.SpacewarGraphics;
import spacesettlers.objects.AbstractObject;
import spacesettlers.objects.Asteroid;
import spacesettlers.objects.Ship;
import spacesettlers.simulator.Toroidal2DPhysics;
import spacesettlers.utilities.Position;


public class GAState {
	double distanceToNearestMineableAsteroid;
	Asteroid nearestMineableAsteroid;
	private UUID currentTarget;
	boolean shouldShoot = false;
	
	UUID targetID = null;
	ArrayList<UUID> path = new ArrayList<UUID>();
	
	int lastTimestep = 0;
	private ArrayList<SpacewarGraphics> graphicsToAdd;
	
	//Magic numbers
	public int EnergyThreshold = 1500;
	public int PathingFrequency = 25;
	public boolean Drawing = true;
	
	Position previousPosition = null;
	
	int sum = 0;
	int count = 0;
	int previousTimestep = 0;
	
	public GAState(Toroidal2DPhysics space, Ship ship) {
		updateState(space, ship);
	}



	public void updateState(Toroidal2DPhysics space, Ship ship) {
		//Find our target
		if(!isValidTarget(space, targetID)){
			targetID = findTarget(space, ship);
		}
		AbstractObject target = space.getObjectById(targetID);
		AbstractObject movementGoal = target;
		//If we're low on energy, look for a beacon close by
		if(ship.getEnergy() < EnergyThreshold){
			movementGoal = Combat.nearestBeacon(space, ship);
		}	
		
		this.path = Pathing.findPath(space, ship, movementGoal);
	}
	/**
	 * Get a target to hunt
	 * @param space
	 * @param ship
	 * @return
	 */
	private UUID findTarget(Toroidal2DPhysics space, Ship ship){
		return Combat.nearestEnemy(space, ship).getId();
	}
	/**
	 * See if we should still chase our current target
	 * @param space
	 * @param targetID
	 * @return
	 */
	private boolean isValidTarget(Toroidal2DPhysics space, UUID targetID){
		return (targetID != null
				&& space.getObjectById(targetID) != null
				&& space.getObjectById(targetID).isAlive());
	}
	/**
	 * Return the nearest asteroid (used for actions)
	 * 
	 * @return
	 */
	public UUID getTarget() {
		
		return this.currentTarget;
	}
	public ArrayList<UUID> returnNextPosition(Toroidal2DPhysics space, Ship ship){
		if(this.path.size() > 0){
			return this.path;
		}
		else{
			updateState(space,ship);
			return this.path;
		}
	}
	public UUID targetReached(){
		this.path.remove(0);
		return this.path.get(0);
	}
	public int stackSize(){
		return this.path.size();
	}
	/**
	 * Generated by eclipse - make sure you update this when you update the state (just use eclipse to regenerate it)
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(distanceToNearestMineableAsteroid);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}


	/**
	 * Generated by eclipse - make sure you update this when you update the state (just use eclipse to regenerate it)
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		GAState other = (GAState) obj;
		if (Double.doubleToLongBits(distanceToNearestMineableAsteroid) != Double
				.doubleToLongBits(other.distanceToNearestMineableAsteroid))
			return false;
		return true;
	}



}
